# 一、Java基础

1. Java和C语言有什么区别？Java好在哪里？

   > Java是面向对象，抽象程序更高，C语言面向过程，偏向底层
   >
   > Java使用虚拟机，屏蔽了指针，C语言需要了解指针，直接和操作系统打交道
   >
   > Java内存自动垃圾回收，C语言内存需要手动回收

2. 怎么理解Java的跨平台性，一次编译到处运行？

   > Java代码编译成中间字节码.class，由各个平台的解释器负责解析为对应平台的运行代码
   >
   > 无论在哪个平台编写代码，编译以后，都可以通过虚拟机跨平台执行

3. 面向对象和面向过程的区别？

   > 面向对象：易维护、易复用、易扩展，根据封装、继承和多态性可以设计出低耦合的系统
   >
   > 面向过程：性能更高，开销较小

4. 如何理解面向对象三大特性：封装、继承、多态？

   > 封装：隐藏实现细节，减少耦合，内部结构自由修改，对成员精确控制
   >
   > 继承：对已存在的类的扩展，方便复用代码，但是破坏了封装，增加了耦合关系
   >
   > 多态：运行时才能确定引用变量的具体类型，通过继承、重写、向上转型或者接口来实现

5. 类继承会有什么问题吗，一般什么情况下才会去用继承？

   > 无法实现多继承和动态继承，无法直接调用父类的私有属性和方法，破坏了封装性，增加了耦合度
   >
   > 解决代码重用，利用设计模式进行代码优化，实现多态的前提条件

6. 为什么重写equals方法还要重写hashcode方法？

   > equals默认是比较引用，验证两个对象是否是同一个对象，所以要重写equals来判断对象是否值相等
   >
   > hashcode原本是一个native方法，返回的是对象的内存地址，所以需要重写
   >
   > equals相同的对象hashcode必须相同，equals不相同的对象hashcode不相同可以提高哈希表的性能
   >
   > hashcode的计算不能依赖对象中易变的数据，否则像hashmap将get不到对应的值

7. 深克隆和浅克隆

8. 反射相关

9. 注解的实现原理

10. Lambda表达式的优缺点？

11. Stream流式编程的好处？终止方法和延迟方法的区别是？终止方法存在的意义是什么？

# 二、Java集合

1. HashMap底层实现（JDK1.7使用数组+链表；JDK1.8使用数组+链表+红黑树）
2. HashMap为什么要引进红黑树？为什么不用其他的平衡二叉树之类的？红黑树的优势在哪里？（AVL树的旋转比红黑树的旋转更加难以平衡和调试，需要更高的旋转次数）
3. 链表会转化为红黑树的两个条件是？（①链表的长度达到8；②HashMap底层使用的table数组长度length达到64；如果不满足后者，将会触发扩容方法）
4. 链表长度大于8转化为红黑树，小于6红黑树转化为链表；为什么不直接设置成大于8转化成红黑树，小于8转化成链表；（中间有个差值7进行过渡是为了避免链表和树频繁转换，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低）
5. 把链表转化为红黑树的阈值是8，为什么不设置成其他值？（遵循泊松分布，链表长度超过8的概率非常小）
6. HashMap扩容机制，即resize方法？（JDK 1.7 会重新计算每个元素的哈希值，JDK1.8是通过高位运算（e.hash & oldCap）来确定元素是否需要移动，如果运算结果值为0，那么元素扩容后位置不变，结果值为1表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度）
7. HashMap添加元素的步骤（put方法）、计算集合元素个数（size方法）
8. HashMap为什么是线程不安全的？（同时新增元素、同时扩容导致数据丢失，jdk1.7头部倒序插入出现死循环导致CPU占用100%）
9. HashMap默认的加载因子是0.75，为什么不设置成1或者0.5（从容量和性能考虑）
10. HashMap发生哈希冲突，新节点是插入到链表头部还是链表的尾部，头部倒序插入死循环是怎么产生的？（jdk1.7采用头部倒序插入，会导致死循环；jdk1.8使用尾部正序插入）
11. Hashtable怎么控制key value 不能为null？（当调用put方法时，首先会判断value是否为null，为null的话直接抛出空指针异常；对于key，由于Hashtable计算hash值是int hash = key.hashCode();直接取对象的hashcode，key为null就会报空指针异常；而HashMap计算hash值是return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，key为null则hash值为0）
12. ConcurrentHashMap底层采用的结构（分jdk1.7和jdk1.8），jdk1.7和jdk1.8分别采用什么方式实现线程安全？（jdk1.7采用分段锁，也就是为每一个segment加上ReentrantLock锁；jdk1.8使用的是CAS机制加上synchronized锁）
13. ConcurrentMap中的size方法是如何实现的？多线程操作下，如果一个线程在查size方法，一个线程在执行put方法，底层是如何控制每次计算出来的值是正确的？
14. HashSet的底层实现？（基于HashMap来实现的，new 一个 HashSet对象底层实际就是new了一个HashMap，并且使用默认的初始容量16和默认的加载因子0.75；当我们往HashSet里面添加一个元素其实就是往HashMap里面put了一个元素，并且是以key存在的，HashMap的value值都是一样的，是一个静态常量PRESENT，源码为：private static final Object PRESENT = new Object(); ）
15. BlockingQueue（阻塞队列）如何实现生产者消费者模型？
16. 线程安全的List有哪些？（Vector、CopyOnWriteArrayList、还可以使用Collections类的synchronizedList方法将线程不安全的List转为线程安全的）
17. 为什么ArrayList查询速度快？（ArrayList底层是基于数组实现，可以根据元素下标进行查询，查询方式为（数组首地址+元素长度*下标，基于这个位置读取相应的字节数就可以了），如果数组存的是对象，怎么根据下标定位元素所在位置？（对象数组每个元素存放的是对象的引用，而引用类型如果开启指针压缩占用4字节，不开启则占用8字节，所以对象数组同样适用上面的公式）
18. ArrayList的扩容？（ArrayList底层是基于数组实现，所以创建ArrayList会给数组指定一个初始容量，默认值为10，因为必须指明数组的长度才能给数组分配空间；由于数组的特性，ArrayList扩容是创建一个更大的数组，然后将原来的元素拷贝到更大的数组中，扩容的核心方法是Arrays.copyOf方法）
19. ArrayList和LinkedList的区别，添加一个元素的时间复杂度各是多少，既然ArrayList添加元素效率没有LinkedList高，为什么我们平时用的比较多的还是ArrayList？
20. 一般什么情况下会用ArrayList，什么情况用LinkedList？（如果只是普通的存取元素多用ArrayList，LinkedList一般用作栈、队列）
21. 将一个Map集合变成栈，如何实现？（我的思路是用TreeMap去实现，key存的是要入栈的元素，value存的是可以记录他们入栈的一个先后顺序的，例如时间戳，然后重写Comparator比较器，根据value进行排序，遍历Map时，先进的后面出）
22. Map集合有迭代器吗？遍历输出Map中所有元素有哪些方法？

# 三、多线程和Java锁

1. 线程池的三大方法、七大参数、四种拒绝策略（可以顺带谈一下阿里巴巴开发手册对于线程池使用的规范）
2. 最大线程数如何定义？（从CPU密集型和IO密集型考虑）
3. 线程池的五种状态（Running、Shutdown、Stop、Tidying、Terminated）
4. 线程池的任务执行流程、excute方法和 submit方法的区别？
5. Synchronized锁和Lock锁的区别
6. Java线程虚假唤醒（线程本应该处于wait状态却被唤醒了，解决方案是wait方法应该用while循环包裹，不用if）
7. JMM的三种特性（原子性、可见性、有序性）、主内存和线程工作内存的八种交互动作
8. volatile如何保证可见性（MESI缓存一致性协议）
9. volatile如何保证有序性（内存屏障——lock前缀指令）
10. synchronized和volatile的区别（volatile是一种非锁机制，这种机制可以避免锁机制引起的线程上下文切换和调度问题。因此，volatile的执行成本比synchronized更低；volatile只能保证可见性有序性；synchronized可以保证原子性可见性有序性）
11. JUC包中的原子类如何保证原子性？（CAS机制和自旋锁）
12. CAS机制，会引发什么问题，如何解决ABA问题？（CAS会导致ABA问题，解决ABA问题是使用版本号机制）
13. 悲观锁和乐观锁的区别，应用？（java中的Synchronized关键字和lock锁使用的都是悲观锁；CAS机制是乐观锁的一种实现方式）
14. 公平锁和非公平锁（公平锁按照先来先服务，不会出现饥饿；非公平锁会导致饥饿，但是效率更高，默认的锁都是非公平的）
15. 自旋锁和互斥锁，自旋锁的优缺点？（优点：减少上下文切换和用户态内核态的切换带来的开销；缺点：循环等待消耗CPU）
16. 可重入锁和不可重入锁（不可重入锁容易导致死锁发生，大多数锁都是可重入的，例如Synchronized锁和ReentrantLock）
17. JDK1.6 Synchronized锁升级（偏向锁—轻量级锁—重量级锁）
18. Synchronized锁的底层实现，锁的是什么，其它线程如何判断该锁已经被占用了？
19. 死锁产生的四个必要条件以及死锁的处理策略

# 四、Mysql

1. Myisam和InnoDB存储引擎的区别？（Myisam不支持外键也不支持事务，支持的是表锁，当执行select操作时，自动给涉及的表加表锁，当执行增删改操作，自动给涉及的表加写锁；InnoDB支持外键也支持事务，支持的是行锁，当执行select操作时，不加任何锁，当执行增删改操作，自动给涉及的行加写锁）
2. 间隙锁是什么？行锁升级为表锁的情况？
3. InnoDB的行锁有哪些？锁住的是行还是索引？（Record Lock、Gap Lock、Next-Key Lock；锁住的是索引，而不是行）
4. 为什么可重复读隔离级别也可以解决幻读？（通过Next-Key Lock可以消除幻读）
5. 并发事务处理带来的四种问题和事务的隔离级别（丢失更新、脏读、不可重复读、幻读；读未提交、读已提交、可重复读、串行化）
6. 如何理解Mysql默认的事务隔离级别可重复读？
7. 事务的ACID属性是如何实现的？（原子性通过回滚日志undo log实现；持久性通过重做日志redo log实现；隔离性通过锁和MVCC实现；而一致性则是通过原子性、隔离性、持久性来实现，只有满足这三个特性，才能实现事务的一致性）
8. 聚簇索引、非聚簇索引、回表查询、覆盖索引；
9. 索引失效的情况？（违反最左前缀法则、范围查询右边的列索引失效、字符串不加单引号、对索引列进行运算、头部模糊匹配、使用不等于！=或者<>）
10. explain分析执行计划、SQL语句的优化
11. mysql三大范式（1NF即原子性，2NF即消除部分依赖，3NF即消除传递依赖）
12. mysql索引的底层实现，为什么用B+树不用B树？（B+树IO次数更少、更适合范围查询、查询效率更加稳定）
13. 哈希表查找速度不是更快吗，为什么不直接使用哈希表来做索引的底层数据结构？（哈希表不支持范围查找）

# 五、Redis

1. Redis五种基本数据类型的使用场景
2. 缓存穿透、缓存击穿、缓存雪崩
3. Redis的过期策略和内存淘汰机制
4. Redis的zset底层数据结构，为什么用跳跃表而不用红黑树

# 六、框架相关

1. Spring AOP的实现原理？（基于动态代理模式，如果目标类实现了接口，那么使用基于接口的动态代理，否则使用基于子类/cglib的动态代理）
2. Spring AOP 的具体加载步骤？
3. AOP和OOP的区别，分别适用什么场景？
4. Spring Bean的作用域，Spring Bean的生命周期（Bean的实例化—初始化Bean—使用Bean—Bean的销毁）
5. Spring容器创建对象的两种时机，各有什么优缺点？（一是Spring容器启动时创建Bean，二是调用getBean方法时创建）
6. SpringMVC的执行流程（可以顺带讲一下适配器模式）
7. Mybatis的一级缓存和二级缓存？
8. Mybatis中#和$的区别？
9. Mybatis如何实现批量插入？
10. Mybatis的xml文件中，sql语句可以使用直接使用大于号小于号吗？应该用什么符号代替？

# 七、设计模式

1. 代理模式（应用：一是创建多线程的方式之使用Runnable接口应用了静态代理；二是Spring AOP应用了动态代理）
2. 适配器模式（应用：一是创建多线程的方式之使用Callable接口；二是SpringMVC中的HandleAdapter）
3. 工厂模式（应用：一是Spring IOC；二是Mybatis中的SqlSessionFactory就用到了简单工厂模式）
4. 单例模式（一般会需要手撕单例模式的代码，主要谈DCL模式关于指令重排的问题，以及反射可以破坏除枚举以外的几种方式；单例模式的应用有：一是Spring Bean的作用域默认就是使用单例模式；二是Mybatis中的ErrorContext类也使用了单例模式，这个类用于记录线程执行环境的错误信息）
5. 装饰器模式（应用：JAVA的IO流就用到了装饰器模式）
6. 装饰器模式和代理模式的区别？
7. 策略模式（应用：Arrays类的sort方法就用到了策略模式，Comparator接口就是一个策略接口，将排序方法定义成一个策略，用户可以自定义排序策略，可以是升序也可以是降序）
8. 观察者模式与发布订阅模式的区别？（JDK源码已经为我们提供好了一套观察者模式，Observer就是观察者接口，Observable类是被观察者，是一个具体类，提供了一个存放所有观察者角色的集合，并且也提供了添加观察者、移除观察者、通知观察者等方法）

# 八、网络

1. TCP三次握手和四次挥手的过程，每次发送的包的内容，客户端和服务端的状态？
2. TCP三次握手可以携带数据吗？TCP协议运行时阶段？
3. 为什么是三次握手，可以四次握手或者两次握手吗？
4. 为什么握手是三次，而挥手要四次？
5. TCP四次挥手为什么需要TIME-WAIT阶段等待2MSL，是哪一方有TIME-WAIT阶段？（主动释放释放连接的那端）
6. TCP的长连接和短连接
7. 半连接队列和全连接队列，什么是syn flood攻击，如何应对syn flood攻击？
8. 在浏览器中输入一个网址回车后发生了什么？
9. 域名解析过程的递归查询和迭代查询
10. 浏览器输入一个网址之后，按照TP/IP参考模型，从应用层到网络层各使用了哪些协议？
    （应用层：HTTP、DNS；传输层：TCP、UDP；网络层：IP、ICMP、ARP）
11. ICMP协议的两个应用——Ping和Traceroute
12. IP地址和MAC地址有什么区别？
13. http和https的区别
14. 网站为什么要使用cookie和session；cookie和session有什么区别？
15. get请求和post请求的区别？
16. TCP和UDP的区别以及各自的应用场景？
17. epoll和select的区别？

# 九、JVM

1. JVM内存模型（程序计数器、虚拟机栈、本地方法栈、堆、方法区）
2. JDK1.8做了哪些变化？（JDK1.7已经将原本位于永久代的字符串常量池移到堆中了，但是永久代的概念还存在，JDK1.8才彻底废除永久代，进而用元空间代替）
3. 永久代和元空间，JDK1.8为什么要使用元空间代替永久代？
4. 元空间溢出？（元空间不属于Java虚拟机，使用的是本地内存，存放的是类及方法的一些信息，动态加载类或者频繁加载类信息，但是没有及时卸载，会导致元空间溢出）
5. 对象创建的两种方式（指针碰撞、空闲列表）、对象访问定位的两种方式（使用句柄、直接指针）
6. 栈上分配与逃逸分析（JVM层面进行java性能优化的技巧）
7. 判断对象是否存活的两种方式，引用计数法的缺点？（引用计数法、可达性分析法）
8. 关于Object类的finalize()方法（jvm自动执行，无需手动调用，只能执行一次）.
9. java的四种引用（强引用、软引用、弱引用、虚引用）
10. 三种垃圾回收算法，各自的优缺点（标记-清除法、标记-复制法、标记-整理法）
11. Minor GC 和 Full GC 的区别，触发条件，以及空间分配担保策略？
12. 内存溢出和内存泄露（内存泄露的堆积会导致内存溢出）
13. JVM参数调优（-Xms、-Xmx、-Xss、-XX:NewRatio、-XX:SurvivorRatio、-XX：+PrintGCDetails、-HeapDumpOnOutOfMemory）
14. 发生OOM如何解决（首先尝试通过JVM参数调优扩大堆内存空间；再者dump出堆内存存储快照，使用JProfile工具进行分析）
15. 垃圾收集器（CMS问的居多，另外，如果谈及发生gc会给用户带来什么不好的体验，可以谈谈Stop the World）
16. 类加载机制的过程，准备阶段做了哪些工作？（准备阶段会给类的静态变量分配内存（方法区）并赋初值，如果类的静态变量被final修饰，那么初始化的值就不是零值，而是声明的值）
17. 类的双亲委派模型定义，双亲委派模型的好处？如何破坏类的双亲委派模型？

# 十、操作系统

1. linux的僵尸进程和孤儿进程的区别，如何清理僵尸进程？（kill僵尸进程的父进程）
2. 如何查看僵尸进程信息？如何统计僵尸进程数量？（ps - ef | grep defunct；ps -ef | grep defunct | wc - l）
3. 并发和并行的区别？
4. 进程和线程的区别？
5. 进程通信的方式有哪些？（管道、消息队列、共享内存、信号量、套接字Socket）