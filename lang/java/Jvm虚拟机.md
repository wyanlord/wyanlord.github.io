### 一、Java内存区域

#### 1、运行时数据库

a）线程共享区域

+ 堆（heap）
  + 新生代 - Minor GC
    + Eden - 80%
    + From Survivor - 10%
    + To Survicor - 10%
  + 老年代 - Major GC
+ 方法区（Method Area）或（PermGen - 永久代）
  + 类信息
  + 运行时常量池 - 字面量和符号引用
  + 静态变量
  + 即时代码

b）线程独有区域

+ 程序计数器
  + 当前线程执行的字节码的行号指示器
+ Java虚拟机栈
  + 局部变量表
  + 操作数栈
+ 本地方法栈
  + 为虚拟机执行Native方法服务

#### 2、直接内存

Direct Memory，主要用于NIO中减少内存复制拷贝，其内存地址由堆中的DirectByteBuffer对象来引用。

#### 3、对象描述

a）对象的创建过程

使用new指令，首先检查new后面跟随的类能否在运行时常量池中找到对应的符号引用，然后检查是否被加载、验证、准备、解析和初始化，然后分配内存大小，优先使用本地线程分配缓冲区-TLAB，再次使用堆内存，并执行零值初始化，然后在对象头中存放类的元数据信息、哈希码和GC分代年龄等信息，最后执行`<init>`方法，将对象按照程序员的意愿进行初始化。

b）对象的内存布局

+ 对象头（header）
  + 哈希码
  + GC分代年龄
  + 锁状态标识
  + 线程持有的锁
  + 偏向线程ID
  + 偏向时间戳
+ 实例数据（Instance Data）
  + 父类继承下来的字段内容
  + 子类本身定义的字段内容
  + 相同宽度的字段总会被分配在一起
  + CompactFields为true时，子类中较窄的字段也会插入到父类变量的空隙中
+ 对齐填充（Padding）
  + 对象头的起始地址是8字节的整数倍
  + 实例数据部分如果没有对齐，则通过对齐填充来不全

c）对象的访问定位

+ 句柄间接访问
  + 引用指向句柄，句柄分为`对象实例数据指针`和`对象类型数据指针`，前者在Java堆中，后者在方法区中
  + 优点是引用指向的句柄地址不会频繁变更，当对象移动时，只会改变实例数据的指针，引用本身不用修改
+ 指针直接访问
  + 引用指向对象，对象由`对象实例数据指针`来表示，实例数据包含了`对象类型数据指针`
  + 优点是引用定位到对象实例数据速度快，开销积少成多后效果明显

#### 4、OOM异常 - OutOfMemoryError（内存溢出异常）

+ Java堆
  + 内存泄漏 - 泄漏对象通过某种路径和GC Roots相关联，导致无法回收
  + 内存不足 - 堆空间设置的太小，无法满足业务的需求
+ 线程栈
  + 线程递归导致的栈深度大于虚拟机允许的最大深度
  + 线程递归导致的扩展栈时无法申请到足够的内存
  + 线程创建过多导致的操作系统无法为栈提供更多的内存空间
+ 方法区
  + 动态代理产生的类元数据信息太多，回收不及时，导致超出方法区的内存上限
  + 使用不当的类方法如`String.intern()`大量创建字符串到运行时常量池，导致内存爆炸
+ 直接内存
  + 使用了NIO，OOM时导出的堆快照很小，大概率判断是Direct Memory内存溢出

### 二、垃圾回收

#### 1、如何判断对象已死亡

+ 引用计数算法
  + 优点是效率高，在C++中共享智能指针就是用的引用计数
  + 缺点是无法解决循环引用问题
+ 根可达性算法
  + 从一系列称为`GC Roots`的对象为起始点，向下搜索，也称为`引用链`
  + 虚拟机栈中的本地变量表中引用的对象
  + 方法区中类的静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中Native方法引用的对象
+ 引用分类
  + 强引用 - 使用new创建的对象的引用
  + 软引用 - 使用SoftReference类创建的引用
  + 弱引用 - 使用WeakReference类创建的引用
  + 虚引用 - 使用PhantomReference类创建的引用
+ 对象死亡过程
  + 引用链不可达，则处于首次标记状态
  + 判断对象是否覆盖finalize方法，并且该方法被调用过，是的话则最终标记
  + 上述的对象finalize方法没有被触发过，则进入F-Queue队列等待finalize被触发
  + 如果上述的对象在finalize中关联上了引用链上的某个引用，则可以拯救自己`一次`
  + 只有标记两次的对象，才会被虚拟机回收

#### 2、垃圾回收算法

+ 标记 - 清除 （Mark-Sweep）
  + 先标记，再清除，是最原始的一种回收算法
  + 缺点一：效率比较低下
  + 缺点二：容易产生内存碎片
+ 复制（Copying）
  + 将内存分为两块，每次使用其中的一块，复制未死亡对象到另一块，然后一次性清理一半空间
  + 优点是效率高，没有内存碎片
  + 缺点一：空间利用率低，毕竟每次只能使用一半的空间
  + 缺点二：对于存活率较高或者内存占用较大的对象，复制的代价高昂
  + 目前采用的是8:1:1的划分比例，原因是大部分的对象都是` 朝生夕死`
+ 标记 - 整理（Mark-Compact）
  + 先标记，再向一端移动，最后清理掉边界以外的内存
  + 适合GC频率较低的老年代使用
+ 分代收集算法
  + 当前商业虚拟机的垃圾收集都是采用该算法，根据存活周期不同分为新生代和老年代
  + 新生代每次垃圾收集都会有大批对象死去，只有少量存活，选用复制算法最佳
  + 老年代中对象存活率高，没有额外的担保，必须使用标记-清除或者标记-整理算法

#### 3、算法实现细节

+ 枚举根节点
  + 根可达性分析需要暂停程序运行（Stop The World）
  + 为了更快的分析出引用链，HotSpot采用一组oopMap的结构来存储，Gc扫描就可以直接获取到引用链
+ 安全点和安全区域
  + 当所有的线程都运行到SafePoint时，才可以获取oopMap的信息
  + 当所有的线程都运行到SafeRegion时，才可以获取oopMap的信息，是SafePoint的优化版

#### 4、垃圾搜集器

新生代搜集器

+ Serial - 单线程，采用复制算法
+ ParNew - 多线程并行，采用复制算法
+ Parallel Scavenge - 多线程并行，采用复制算法，吞吐量优先

老年代搜集器

+ Serial Old - 单线程，采用标记-整理算法
+ Parallel Old - 多线程并行，采用标记-整理算法

+ CMS - Concurrent Mark Sweep，初始标记、并发标记、重新标记、并发清理，无法清理浮动垃圾，容易产生内存碎片

#### 5、内存分配与回收策略

+ 对象优先在Eden分配 - 朝生夕死
+ 大对象直接进入老年代 - 这里容易发生OOM
+ 长期存活对象将进入老年代 - 例如大于默认的15岁
+ 动态对象年龄判断 - 相同年龄所有对象大小大于survivor的一半，直接晋升老年代
+ 空间分配担保 - 老年代给Minor GC进行空间担保，否则进行Full GC

### 三、类加载机制

#### 1、类加载过程

+ 加载

  + 压缩包文件中加载，如JAR， EAR，WAR
  + 从网络中获取，如Applet
  + 运行时动态生成，如JDK的动态代理Proxy
  + 由其他文件生成，如JSP
  + 从数据库中读取

+ 验证

  + 文件格式
  + 元数据
  + 字节码
  + 符号引用

+ 准备

  + 类变量分配内存
  + 类变量设置初始值

+ 解析

  + 查找符号引用对应的直接引用， 如#5这种符号，以及#5代表的真正的引用地址
  + 替换符号引用为直接引用，直接引用是可以直接定位到目标的，如指针或者句柄

+ 初始化

  + 调用cinit方法，静态变量和静态代码块，都是在这个函数中执行的
  + 如果有父类的cinit方法，则首先调用父类的cinit

#### 2、类加载器

+ 启动类加载器
+ 扩展类加载器
+ 应用类加载器

#### 3、双亲委派模型

+ 带有优先级的组织类加载器之间的关系，优先执行父类加载器，没有父类则执行启动类，都没有则执行自己
+ SPI代码没有遵循该模型，使用的是线程上下文类加载器，例如JNDI，JDBC，JBI等



